<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // | 相同位有一个为1 就为1
    // & 相同位都为1 就为1
    // ^ 相同位两个值相反，就为1
  </script>

  <!-- <script>
    // twoSum
    var twoSum = function (nums, target) {
      const len = nums.length;
      const dataMap = new Map();
      let arr = [];
      console.log('arr: ', arr);
      dataMap.set(nums[0], 0);
      for (let i = 1; i < len; i++) {
        const other = target - nums[i];
        console.log('other: ', other);
        if (dataMap.get(other) !== undefined) {
          console.log('dataMap.get(other): ', dataMap.get(other));
          arr = [dataMap.get(other), i];
          console.log('arr: ', arr);
          return [dataMap.get(other), i];
        }
        console.log('arr: ', arr);
        dataMap.set(nums[i], i);
      }
      console.log('arr: ', arr);
      return arr;
    };
    let res = twoSum([3, 3], 6)
    console.log('res: ', res);
  </script> -->
  <!-- <script>
    // 整数翻转
    // var reverse = function (x) {
    //   const max = Math.pow(2, 31) - 1;
    //   const min = Math.pow(-2, 31);
    //   if (x < min || x > max || x == 0) {
    //     return 0;
    //   }
    //   // true 负数 false 正数
    //   // let flag = (x + "").startsWith("-");
    //   // 正数返回1 负数返回-1
    //   let flag = Math.sign(x) < 0;
    //   let str = Math.abs(x) + "";
    //   str = str.replace(/0+&/g, "");
    //   const reverseStr = str.split("").reverse().join("");
    //   const res = flag ? 0 - reverseStr : reverseStr - 0;
    //   if (res < min || res > max) {
    //     return 0;
    //   }
    //   return res;
    // };
    var reverse = function (x) {
      let res = 0;
      while (x) {
        res = res * 10 + x % 10;
        // 按位或 变为整数
        x = x / 10 | 0;
      }
      // res 按位或 转为二进制 ，与res比较时如果相等，没有益处
      return (res | 0) === res ? res : 0;
    };
    console.log('reverse(123): ', reverse(123));
    console.log('reverse(120): ', reverse(120));
    console.log('reverse(-123): ', reverse(-123));
    console.log('reverse(901000): ', reverse(901000));
    console.log('reverse(1534236469): ', reverse(1534236469));
  </script> -->

  <!-- <script>
    // 回文数字
    // var isPalindrome = function (x) {
    //   // 0
    //   if (x >= 0 && x < 10) return true;
    //   // 负数
    //   if (Math.sign(x) < 0) return false;
    //   const numArr = (x + "").split("");
    //   const len = numArr.length;
    //   // 比较数组两头数据 left ，right  
    //   // 值相等 且 right - left == 1 || right == left 是回文数字
    //   for (let i = 0; i < len; i++) {
    //     const left = i;
    //     const right = len - 1 - i;
    //     if (numArr[left] !== numArr[right]) {
    //       return false;
    //     }
    //     if (right - left == 1 || right == left) {
    //       return true;
    //     }
    //   }
    // };

    var isPalindrome = function (x) {
      // 0 -9
      if (x >= 0 && x < 10) return true;
      // 负数
      if (Math.sign(x) < 0) return false;
      if (!(x % 10)) return false;
      let res = 0;
      let x2 = x;
      while (x2) {
        res = res * 10 + (x2 % 10);
        x2 = (x2 / 10) | 0;
      }
      return res === x;
    };
    console.log('isPalindrome(123): ', isPalindrome(123));
    console.log('isPalindrome(121): ', isPalindrome(121));
    console.log('isPalindrome(10): ', isPalindrome(10));
    console.log('isPalindrome(9): ', isPalindrome(9));
  </script> -->

  <!-- <script>
    // 最长公共前缀
    var longestCommonPrefix = function (strs) {
      if (!strs || !strs.length) {
        return "";
      }
      if (strs.length === 1) {
        return strs[0];
      }
      // let str = "";
      let sign = "";
      let word = strs[0];
      let wordList = strs.slice(1);
      for (let i = 0; i < word.length; i++) {
        let char = word[i];
        let flag = true;
        wordList.forEach(item => {
          // 不相同
          if (item[i] != char) {
            flag = false;
          }
        });
        // 相同
        if (flag) {
          sign += char;
        } else {
          return sign;
        }
        //  else {
        //   // 不同
        //   if (sign.length > str.length) {
        //     str = sign;
        //   }
        //   sign = "";
        //   flag = true;
        // }
      }
      return sign;
    };
  </script> -->

  <!-- <script>
    // 有效的括号 栈
    // var isValid = function (s) {
    //   if (s.length < 2) return false;
    //   let stack = [s[0]];
    //   let signMap = { "}": "{", ")": "(", "]": "[" };
    //   for (let i = 1; i < s.length; i++) {
    //     let sign = s[i];
    //     // 注意 stack 为空时
    //     let stackEndSign = stack[stack.length - 1];
    //     // 栈尾 和 当前标志 为一对，且栈不为空
    //     if (signMap[sign] == stackEndSign && stack.length) {
    //       stack.pop();
    //     } else {
    //       stack.push(sign);
    //     }
    //   }
    //   return !stack.length;
    // };
    var isValid = function (s) {
      let len = s.length;
      // 按位与 奇数与1 与 得1 ，偶数得0
      if (len & 1) return false;
      let stack = [];
      let signMap = { "}": "{", ")": "(", "]": "[" };
      for (let i = 0; i < len; i++) {
        let sign = s[i];
        if (signMap[sign]) {
          if (stack.pop() != signMap[sign]) {
            return false;
          }
        } else {
          stack.push(sign);
        }
      }
      return !stack.length;
    };

    console.log('isValid("()"): ', isValid("()"));
    console.log('isValid("()[]{}"): ', isValid("()[]{}"));
  </script> -->

  <!-- <script>
    // 合并两个有序链表
    var mergeTwoLists = function (l1, l2) {
      if (l1 == null) return l2;
      if (l2 == null) return l1;
      if (l1.val <= l2.val) {
        let next = mergeTwoLists(l1.next, l2);
        l1.next = next
        return l1;
      } else {
        let next = mergeTwoLists(l1, l2.next);
        l2.next = next
        return l2;
      }
    };
  </script> -->

  <!-- <script>
    // 删除数组中重复项
    // var removeDuplicates = function (nums) {
    //   if (nums.length < 2) return nums.length;
    //   let map = {}
    //   let i = 0;
    //   let sign = 'key';
    //   nums.push(sign)
    //   while (nums[i] != sign) {
    //     let num = nums.shift();
    //     console.log('num: ', num);
    //     if (num != sign && !map[num]) {
    //       map[num] = num
    //       nums.push(num)
    //     }
    //   }
    //   nums.shift()
    //   return nums.length
    // };
    var removeDuplicates = function (nums) {
      if (nums.length < 2) return nums.length;
      if (nums.length == 2) return nums[0] == nums[1] ? 1 : 2;
      let writeIdx = 0;
      // [1,1,2,3]
      for (let i = 1; i < nums.length; i++) {
        if (nums[i] != nums[i - 1]) {
          nums[++writeIdx] = nums[i];
        }
      }
      return writeIdx + 1;
    };
    console.log('removeDuplicates([1,1,2]): ', removeDuplicates([1, 1, 2]));

  </script> -->

  <!-- <script>
    // 动态规划 322 最少零钱问题
    // var coinChange = function (coins, amount) {
    //   if (amount <= 0) return 0;
    //   // 设置 长度为 amount +1 的数组 下标为对应的金额，值为对应金额使用最少的硬币数
    //   // 初始化 0 为0 其他金额值为-1
    //   // [0,-1,-1,-1,-1,-1,...]
    //   const dp = new Array(amount + 1).fill(-1);
    //   dp[0] = 0;

    //   // 计算每个金额使用的最少硬币
    //   // 如 coins = [1, 2, 5], amount = 11
    //   for (let i = 1; i < amount + 1; i++) {
    //     // 硬币与 amount 等额，最少硬币为1
    //     if (coins.includes(i)) {
    //       dp[i] = 1;
    //     } else {
    //       // 不等
    //       let min = -1;
    //       // 找到 种硬币最小的组合
    //       for (let j = 0; j < coins.length; j++) {
    //         let coin = coins[j]
    //         if (i > coin) {
    //           // 找到 剩余硬币 最小的组合
    //           let res = i - coin;
    //           // 排除 dp[res]  初始值
    //           if (dp[res] !== -1) {
    //             if (min === -1) {
    //               min = dp[res] + 1;
    //             } else {
    //               // 如果比当前结果大 覆盖当前结果
    //               min > dp[res] + 1 && (min = dp[res] + 1);
    //             }
    //           }
    //         }
    //       }
    //       dp[i] = min;
    //     }
    //   }

    //   console.log('dp: ', dp);
    //   return dp[amount];
    // };
    var coinChange = function (coins, amount) {
      if (amount <= 0) return 0;
      // 设置 长度为 amount +1 的数组 下标为对应的金额，值为对应金额使用最少的硬币数
      // 初始化 0 为0 其他金额值为-1
      // [0,-1,-1,-1,-1,-1,...]
      const dp = new Array(amount + 1).fill(Infinity);
      dp[0] = 0;

      // 计算每个金额使用的最少硬币
      // 如 coins = [1, 2, 5], amount = 11
      for (let i = 1; i < amount + 1; i++) {
        // 硬币与 amount 等额，最少硬币为1
        if (coins.includes(i)) {
          dp[i] = 1;
        } else {
          let min = dp[i];
          // 找到 种硬币最小的组合
          for (let coin of coins) {
            let res = i - coin;
            if (res >= 0) min > dp[res] + 1 && (min = dp[res] + 1);
          }
          dp[i] = min;
        }
      }
      console.log("dp: ", dp);
      return dp[amount];
    };
    // console.log(' coinChange([1,2,5],11): ', coinChange([1, 2, 5], 11));
    // console.log(' coinChange([1,2,5],4): ', coinChange([1, 2, 5], 4));
    // console.log(' coinChange([1,2,5],5): ', coinChange([1, 2, 5], 5));
    // console.log(' coinChange([1,2,5],6): ', coinChange([1, 2, 5], 6));
    console.log(' coinChange([1,2,5],10): ', coinChange([1, 2, 5], 10));
  </script> -->
  <!-- <script>
    //  70 爬楼梯 方式 : 动态规划
    var climbStairs = function (n) {
      const dp = [];
      dp[0] = 1;
      dp[1] = 1;
      for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
      }
      return dp[n];
    };
    // console.log('climbStairs(3): ', climbStairs(4));
    console.log('climbStairs(3): ', climbStairs(5));
  </script> -->
  <!-- <script>
    //  120 三角形最短路径 动态规划
    var minimumTotal = function (triangle) {
      let startIdx = 0;
      let idx = startIdx;
      let row = triangle[0];
      // 当前层 与 以前层的和 row 求最小值 新row
      for (let i = 1; i < triangle.length; i++) {
        let currentRow = triangle[i];
        let cLen = currentRow.length;
        // let currentIdxNum = currentRow[idx];
        let addList = [];
        for (let c = 0; c < cLen; c++) {
          let min = Infinity;
          if (row[c] != undefined) {
            let rowC = row[c] + currentRow[c];
            min = min > rowC ? rowC : min;
          }
          if (row[c - 1] != undefined) {
            let rowPre = row[c - 1] + currentRow[c];
            min = min > rowPre ? rowPre : min;
          }
          // if (row[c + 1]) {
          //   let rowNext = row[c + 1] + currentRow[c];
          //   min = min > rowNext ? rowNext : min;
          // }
          addList[c] = min;
        }
        row = addList;
        console.log('row: ', row);
      }
      return Math.min(...row);
    };

    // console.log(' minimumTotal([[-1], [-2, -3]]): ', minimumTotal([[-1], [-2, -3]]));
    // console.log(' minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]): ', minimumTotal([[2], [3, 4], [6, 5, 7], [4, 1, 8, 3]]));
    // console.log(' minimumTotal([[1],[-5,-2],[3,6,1],[-1,2,4,-3]])): ', minimumTotal([[1], [-5, -2], [3, 6, 1], [-1, 2, 4, -3]]));
    console.log(' minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]])): ', minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]]));
  </script> -->

  <!-- <script>
    //  64 最小路径 动态规划
    //  暴力递归解决 自顶而下
    //  动态规划思路   自底而上 寻找规律 缓存结果 
    var minPathSum = function (grid) {
      let len = grid.length;
      let m = grid.length;
      let n = grid[0].length;
      let arr = new Array(m).fill(0)
      arr.forEach((item, i) => {
        arr[i] = new Array(n).fill(Infinity)
      })
      // let arr = grid;
      console.log('arr: ', arr);
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          let min = Infinity;
          if (i - 1 >= 0 && j - 1 >= 0) {
            min = Math.min(arr[i - 1][j], arr[i][j - 1])
          } else if (i - 1 >= 0) {
            min = arr[i - 1][j]
          } else if (j - 1 >= 0) {
            min = arr[i][j - 1]
          } else {
            min = 0;
          }
          arr[i][j] = min + grid[i][j]
        }
      }
      return arr[m - 1][n - 1]
    };
    console.log('minPathSum([[1,3,1],[1,5,1],[4,2,1]]): ', minPathSum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]));
  </script> -->

  <!-- <script>
    // 343 整数拆分 
    // 1. dp[i] = (i-j)*dp[j]
    // 2. dp[i] = Math.max(1*dp[i-1],2*dp[i-2],3*dp[i-3])
    var integerBreak = function (n) {
      let dp = new Array(n + 1).fill(0);
      dp[1] = 1;
      for (let i = 2; i < dp.length; i++) {
        let res = 0;
        let j = i;
        while (j > 0) {
          let dpNum = dp[--j]
          let r = dpNum * (i - j);
          let r1 = (i - j) * j
          res = Math.max(res, r, r1)
          // console.log('res: ', res);
          // r > res && (res = r);
        }
        dp[i] = res;
        res = 0;
      }
      console.log("dp: ", dp);
      return dp[n];
    };
    // console.log('integerBreak(2): ', integerBreak(2));
    // console.log('integerBreak(3): ', integerBreak(3));
    // console.log('integerBreak(4): ', integerBreak(4));
    console.log('integerBreak(10): ', integerBreak(10));
  </script> -->

  <!-- <script>
    //  279 完全平方数 动态规划
    // 此方法超时
    var numSquares = function (n) {
      if ((n == 1)) return 1;
      let dp = new Array(n + 1).fill(Infinity);
      dp[0] = 0;
      dp[1] = 1;
      let len = dp.length;
      //num % 1 === 0  为整数
      // Math.sqrt(num) 平方根
      for (let i = 2; i < len; i++) {
        if (Math.sqrt(i) % 1 === 0) {
          dp[i] = 1;
          continue;
        }
        let j = i;
        let min = Infinity;
        while (j > 0) {
          if (Math.sqrt(j) % 1 === 0) {
            if (Math.sqrt(i - j) % 1 === 0) {
              min = Math.min(min, 2);
            }
            min = Math.min(dp[i - j] + 1, min);
          }
          j--;
        }
        dp[i] = min;
        min = Infinity;
      }
      console.log('dp: ', dp);
      return dp[n];
    };

    // console.log('numSquares(1): ', numSquares(1));
    // console.log('numSquares(2): ', numSquares(2));
    // console.log('numSquares(3): ', numSquares(3));
    // console.log('numSquares(4): ', numSquares(4));
    // console.log('numSquares(5): ', numSquares(5));
    // console.log('numSquares(12): ', numSquares(12));
    // console.log('numSquares(13): ', numSquares(13));
    console.log('numSquares(8609): ', numSquares(8609));
  </script> -->

  <!-- <script>
    //  62 不同路径 ，动态规划
    //  暴力递归解决 自顶而下
    //  动态规划思路   自底而上 寻找规律 缓存结果 
    //  arr[i][j] = arr[i - 1][j] + arr[i][j - 1];


    // var uniquePaths = function (m, n) {
    //   let arr = new Array(m + 1).fill(0);
    //   arr.forEach((item, i) => {
    //     arr[i] = new Array(n + 1).fill(0);
    //   });
    //   let max = (arr[1][1] = 1);
    //   for (let i = 1; i <= m; i++) {
    //     for (let j = 1; j <= n; j++) {
    //       if (i == 1 && j == 1) continue;
    //       arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
    //       max < arr[i][j] && (max = arr[i][j]);
    //     }
    //   }
    //   // const list = arr.flat();
    //   // console.log("list: ", list);
    //   // return Math.max(...list);
    //   return max
    // };

    var uniquePaths = function (m, n) {
      let arr = new Array(m + 1).fill(0);
      arr.forEach((item, i) => {
        arr[i] = new Array(n + 1).fill(0);
      });
      arr[1][1] = 1;
      let i = 1;
      let j = 1;
      while (i <= m && j <= n) {
        if (i !== 1 || j !== 1) {
          arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
        }
        if (j == n) {
          j = 0;
          i++;
        }
        if (i == m && j == n) {
          i++;
          j++;
        }
        j < n && j++;
      }
      console.log("arr: ", arr);

      return arr[m][n];
    };

    // console.log('uniquePaths(3,3): ', uniquePaths(3, 3));
    // console.log('uniquePaths(3,7): ', uniquePaths(3, 7));
    console.log('uniquePaths(2,1): ', uniquePaths(2, 1));
  </script> -->

  <!-- <script>
    //  27 移除元素
    var removeElement = function (nums, val) {
      let idx = 0;
      // if (nums[idx] == val) {
      //   idx++;
      // }
      nums.forEach((item, i) => {
        if (item == val && i == idx) {
          idx++;
        } else if (item == val && idx < i) {
          nums[idx] = nums[idx] ^ nums[i];
          nums[i] = nums[idx] ^ nums[i];
          nums[idx] = nums[idx] ^ nums[i];
          idx++;
        }
      });

      while (idx-- > 0) {
        nums.shift()
      }
      return nums.length
    };
    removeElement([0, 1, 2, 2, 3, 0, 4, 2], 2)
  </script> -->

  <!-- <script>
    // 28 
    var strStr = function (haystack, needle) {
      if (haystack == needle) return 0;
      if (needle === "") return 0;
      const len = haystack.length;
      let idx = 0;
      let start = needle[idx];
      let startIdx = -1;
      for (let i = 0; i < len; i++) {
        // 匹配开头
        if (haystack[i] == start) {
          // 全部匹配
          if (idx == needle.length - 1) {
            return i - idx;
          }
          start = needle[++idx];
        } else { //不匹配 复原
          i = i - idx ;
          idx = 0;
          start = needle[idx];
        }
      }
      return startIdx;
    };

    // console.log('strStr("mississippi", "issi"): ', strStr("mississippi", "issi"));
    console.log('strStr("mississippi","issip"): ', strStr("mississippi","issip"));
  </script> -->


  <!-- <script>
    //  35 搜索位置插入
    // var searchInsert = function (nums, target) {
    //   // 边界条件 小于第一个 或大于最后一个
    //   if (nums[0] > target) {
    //     // nums.shift(target);
    //     // return nums;
    //     return 0;
    //   }
    //   if (nums[nums.length - 1] < target) {
    //     // nums.push(target);
    //     // return nums;
    //     return nums.length;
    //   }

    //   for (let i = 0; i < nums.length; i++) {
    //     if (nums[i] == target) return i;
    //     if (nums[i] < target && nums[i + 1] > target) {
    //       return i+1;
    //     }
    //   }
    // };
    var searchInsert = function (nums, target) {
      for (let i = 0; i < nums.length; i++) {
        if (target <= nums[i]) return i;
      }
      return nums.length;
    };
    console.log('searchInsert([1,3,5,6],2): ', searchInsert([1, 3, 5, 6], 2));

  </script> -->

  <!-- <script>
    //  53 最大子序列和

    // 内存爆炸版
    // var maxSubArray = function (nums) {
    //   if (nums.length == 1) return nums[0];
    //   let len = nums.length;
    //   let dp = new Array(len)
    //     .fill(-Infinity)
    //     .map(item => new Array(len).fill(-Infinity));
    //   // let idx = 0;
    //   // Math.max(nums[idx], nums[idx] + nums[idx + 1]);
    //   for (let i = 0; i < len; i++) {
    //     for (let j = 0 + i; j < len; j++) {
    //       if (j == i) {
    //         dp[i][j] = nums[i]
    //       } else {
    //         dp[i][j] = nums[j] + dp[i][j - 1]
    //       }
    //     }
    //   }
    //   return Math.max(...dp.flat())
    // };

    // 性能极差版
    // var maxSubArray = function (nums) {
    //   if (nums.length == 1) return nums[0];
    //   let len = nums.length;
    //   let max = -Infinity;
    //   let dp = new Array(len).fill(-Infinity)
    //   for (let i = 0; i < len; i++) {
    //     for (let j = 0 + i; j < len; j++) {
    //       if (j == i) {
    //         dp[j] = nums[i]
    //       } else {
    //         dp[j] = nums[j] + dp[j - 1]
    //       }
    //     }
    //     let rowMax = Math.max(...dp)
    //     if (rowMax > max) {
    //       max = rowMax
    //     }
    //     dp.fill(-Infinity)
    //   }
    //   // console.log('dp: ', dp);
    //   // console.log('dp.flat(): ', dp.flat());
    //   // return Math.max(...dp.flat())
    //   return max;
    // };

    // 性能很差版
    // var maxSubArray = function (nums) {
    //   if (nums.length == 1) return nums[0];
    //   let len = nums.length;
    //   let max = -Infinity;
    //   let arr = []
    //   for (let i = 0; i < len; i++) {
    //     for (let j = 0 + i; j < len; j++) {
    //       if (j == i) {
    //         arr.push(nums[i])
    //       } else {
    //         next = nums[j] + arr[arr.length - 1];
    //         arr.push(next)
    //       }
    //     }
    //     let rowMax = Math.max(...arr)
    //     max = rowMax > max ? rowMax : max;
    //     arr = []
    //   }
    //   return max;
    // };

    //  性能优化版
    // var maxSubArray = function (nums) {
    //   if (nums.length == 1) return nums[0];
    //   let len = nums.length;
    //   let max = -Infinity;
    //   let rowMax = -Infinity;
    //   for (let i = 0; i < len; i++) {
    //     for (let j = 0 + i; j < len; j++) {
    //       if (j == i) {
    //         rowMax = nums[i];
    //         max = rowMax > max ? rowMax : max;
    //       } else {
    //         next = nums[j] + rowMax;
    //         if (next > max) {
    //           max = next;
    //         }
    //         rowMax = next;
    //         // rowMax = next > rowMax ? next : rowMax;
    //       }
    //     }
    //     // console.log("rowMax: ", rowMax);
    //     // console.log('max: ', max);
    //   }
    //   return max;
    // };

    //  终极版
    var maxSubArray = function (nums) {
      if (nums.length == 1) return nums[0];
      let len = nums.length;
      let max = nums[0];
      let next = nums[0];
      for (let i = 1; i < len; i++) {
        next = Math.max(nums[i], nums[i] + next);
        next > max && (max = next);
        // rowMax = next;
        // console.log("rowMax: ", rowMax);
        // console.log('max: ', max);
      }
      return max;
    };
    // [-2,1,-3,4,-1,2,1,-5,4]
    console.log('maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]): ', maxSubArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));
  </script> -->

  <!-- <script>
    //  58 最后一个单词长度

    // api 解法
    // var lengthOfLastWord = function (s) {
    //   s = s.trim();
    //   if (!s) return 0;
    //   const word = s.slice(s.lastIndexOf(" ") + 1);
    //   return word.length;
    // };

    var lengthOfLastWord = function (s) {
      let end = s.length - 1;
      while (end > 0 && s.charAt(end) == " ") end--;
      if (end < 0) return 0;
      let start = end;
      while (start >= 0 && s.charAt(start) != " ") start--;
      return end - start;
    };


  </script> -->
  <!-- <script>
    //  66 加一
    var plusOne = function (digits) {
      let arr = [];
      // 为true 加一
      let sign = true;
      for (let i = digits.length - 1; i >= 0; i--) {
        let num = digits[i];
        if (sign) {
          num++;
          sign = false;
          if (num > 9) {
            num = 0;
            sign = true;
          }
        }
        arr.unshift(num);
        if (i == 0 && num == 0) {
          arr.unshift(1)
        }
      }
      return arr;
    };
    console.log('plusOne([9]): ', plusOne([9]));
  </script> -->

  <!-- <script>
    // 67 二进制求和
    var addBinary = function (a, b) {
      let lenA = a.length - 1;
      let lenB = b.length - 1;
      let add = "";
      // 是否有进制
      let sign = false;
      while (lenA >= 0 || lenB >= 0) {
        let lastA = a[lenA] == undefined ? "0" : a[lenA];
        let lastB = b[lenB] == undefined ? "0" : b[lenB];
        let sum = lastA + lastB;
        sum = sum == "10" ? "01" : sum;
        if (sum == "11") {
          if (sign) {
            sum = "1";
          } else {
            sum = "0";
            sign = true;
          }
        } else {
          if (sign) {
            sum = (sum % 2) + 1;
            sign = sum == 2;
            sum %= 2;
          } else {
            sum %= 2;
          }
        }
        add = sum + add;
        if (sign && lenA <= 0 && lenB <= 0) {
          add = 1 + add;
        }
        lenB--;
        lenA--;
      }
      return add;
    };


    // var addBinary = function (a, b) {
    //   let i = a.length - 1; // a 的最大索引
    //   let j = b.length - 1; // b 的最大索引
    //   let res = "";
    //   let c = 0; // 记录进位
    //   while (i >= 0 || j >= 0 || c) {
    //     // 从后面往前加
    //     let aa = +a[i--] || 0;
    //     let bb = +b[j--] || 0;
    //     let total = aa + bb + c;
    //     // 除2 按位或取整
    //     c = (total / 2) | 0;
    //     // 二进制运算
    //     total %= 2;
    //     // 拼接结果
    //     res = total + "" + res;
    //   }
    //   return res;
    // };

    console.log('addBinary("11","1"): ', addBinary("11", "1"));
    // console.log('addBinary("1","0"): ', addBinary("1", "0"));
  </script> -->

  <!-- <script>
    //  69 平方根
    var mySqrt = function (x) {
      if (x < 2) return x;
      let n = x >> 1;
      let left = 1;
      let right = n + 1;
      while (left + 1 < right) {
        let mid = (left + right) >> 1;
        if (mid * mid == x) return mid;
        if (mid * mid < x) {
          left = mid;
        } else {
          right = mid;
        }
      }

      console.log('left: ', left);
      console.log('right: ', right);
      return left;
      // let i = 0;
      // while (i <= n) {
      //   if (i * i == x) return i;
      //   if (i * i < x && (i + 1) * (i + 1) > x) return i;
      //   i++;
      // }
    };

    console.log('mySqrt(3): ', mySqrt(3));
    console.log('mySqrt(4): ', mySqrt(4));
    console.log('mySqrt(8): ', mySqrt(8));
    console.log('mySqrt(11): ', mySqrt(11));
  </script> -->

  <!-- <script>
    //  83 删除链表重复项
    // @lc code=start
    /**
     * Definition for singly-linked list.
     * function ListNode(val, next) {
     *     this.val = (val===undefined ? 0 : val)
     *     this.next = (next===undefined ? null : next)
     * }
     */
    var deleteDuplicates = function (head) {
      let diffNode = head;
      let currentNode = head;
      while (currentNode) {
        if (currentNode.next && currentNode.val == currentNode.next.val) {
          currentNode = currentNode.next;
        } else {
          diffNode.next = currentNode.next;
          currentNode = diffNode = currentNode.next;
        }
      }
      return head;
    };
    let node3 = { val: 2, next: null }
    let node2 = { val: 1, next: node3 }
    let node1 = { val: 1, next: node2 }

    // deleteDuplicates(node1)
    console.log('deleteDuplicates(node1): ', deleteDuplicates(node1));
  </script> -->

  <!-- <script>
    // 88 合并有序数组

    var merge = function (nums1, m, nums2, n) {
      while (n > 0) {
        nums1[m + n - 1] = (nums1[m - 1] > nums2[n - 1]) ? nums1[--m] : nums2[--n];
      }
      return nums1;
    };

    // merge([1,2,3,0,0,0],3,[2,5,6],3)
    // console.log('merge: ', merge([0], 0, [1], 1));
    console.log('merge([1,2,3,0,0,0],3,[2,5,6],3): ', merge([1, 2, 3, 0, 0, 0], 3, [2, 5, 6], 3));
    // console.log('merge: ', merge([4, 5, 6, 0, 0, 0], 3, [1, 2, 3], 3));
    // console.log('merge: ', merge([4, 0, 0, 0, 0, 0], 1, [1, 2, 3, 5, 6], 5));
  </script> -->


  <script>
    //  100 相同的tree
    // 递归解题
    // var isSameTree = function (p, q) {
    //   if (p == q) {
    //     return true;
    //   }
    //   if (q == null || p == null) return false;
    //   if (p.val != q.val) {
    //     return false;
    //   } else {
    //     let lRes = isSameTree(p.left, q.left);
    //     let rRes = isSameTree(p.right, q.right);
    //     if (!lRes || !rRes) {
    //       return false;
    //     }
    //     return true;
    //   }
    // };

    //  列队
    var isSameTree = function (p, q) {
      const queue = [{ p, q }];
      while (queue.length) {
        const cur = queue.shift();
        if (cur.p == null && cur.q == null) continue;
        if (cur.p == null || cur.q == null) return false;
        if (cur.p.val != cur.q.val) return false;
        queue.push(
          { p: cur.p.left, q: cur.q.left },
          { p: cur.p.right, q: cur.q.right }
        );
      }
      return true;
    };
  </script>

</body>
<!-- <script>
  //  aaabbcccdddddaaaaaddddeeeecccccc 找出连续重复最多的字符
  function repeatMax(str) {
    const len = str.length;
    console.log('len: ', len);
    let i = 0;
    let j = 1;
    let repeat = 0;
    while (i < len - 1) {
      let char = str[i]
      let charAtj = str[j]
      if (charAtj === char) {
        j++
      } else {
        repeat = j - i;
        console.log('repeat: start:' + i + ',end:' + j, str.slice(i, j), repeat);
        i = j++;
      }
    }
    return repeat;
  }
  const str1 = 'aaabbcccdddddaaaaaddddeeeeccccccc'
  console.log('repeatMax(str1): ', repeatMax(str1));
</script> -->
<!-- <script>
  // 1[2[1[a][3[bc]]]] 转化 abcbcbcabcbcbc
  // 规则  重复1次(重复2次 (a 拼接( 重复3次bc )))
  function parseTemplate(templateStr) {
    const len = templateStr.length;
    // 存放重复倍数
    const stack1 = [];
    // 存放字符串
    const stack2 = [];
    let idx = 0;
    // 匹配 1[
    let regTagLeft = /^(\d*)\[/;
    let regTagRight = /^(\d*\w*)\]/;
    while (idx < len - 1) {
      let str = templateStr.slice(idx);
      console.log('str: ', str);
      // 判断[之前的字符 进栈
      if (regTagLeft.test(str)) {
        let res = str.match(regTagLeft)
        let num = +res[1] == 0 ? 1 : +res[1];
        stack1.push(num)
        stack2.push('')
        idx += res[0].length;
      } else if (regTagRight.test(str)) {
        // 判断]之前的字符 出栈并按照规则累加
        let res = str.match(regTagRight)
        let num = stack1.pop();
        let str1 = stack2.pop();
        // 匹配字符以当前栈顶字符相加 在重复次数
        stack2[stack2.length - 1] += (str1+res[1]).repeat(num);
        idx += res[0].length;
      }
    }
    console.log('stack1: ', stack1);
    console.log('stack2: ', stack2);
    return stack2[0].repeat(stack1[0]);
  }
  // parseTemplate("1[2[1[a][3[bc]]]]")
  console.log('parseTemplate("3[2[a]2[b]]"): ', parseTemplate("3[2[a]2[b]]"));
  console.log('parseTemplate("1[2[1[a][3[6bc]]]]"): ', parseTemplate("1[2[1[a][3[6bc]]]]"));

</script> -->

</html>